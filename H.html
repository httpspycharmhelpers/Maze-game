<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E̲̅҉̲̅n̲̅҉̲̅d̲̅҉̲̅l̲̅҉̲̅e̲̅҉̲̅s̲̅҉̲̅s̲̅҉̲̅ ̲̅҉̲̅d̲̅҉̲̅r̲̅҉̲̅e̲̅҉̲̅a̲̅҉̲̅m</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }
        
        #header {
            height: 100px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 20px;
            background: linear-gradient(180deg, rgba(20,0,0,0.8) 0%, rgba(10,0,0,0.5) 100%);
            z-index: 10;
            border-bottom: 1px solid #500;
            box-shadow: 0 5px 15px rgba(100,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        #header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 3px,
                rgba(150,0,0,0.1) 3px,
                rgba(150,0,0,0.1) 6px
            );
            pointer-events: none;
        }
        
        #game-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            letter-spacing: 2px;
            position: relative;
            z-index: 2;
        }
        
        #game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #controls {
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(0deg, rgba(20,0,0,0.8) 0%, rgba(10,0,0,0.5) 100%);
            padding: 10px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            border-top: 1px solid #500;
            box-shadow: 0 -5px 15px rgba(100,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        #controls::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 3px,
                rgba(150,0,0,0.1) 3px,
                rgba(150,0,0,0.1) 6px
            );
            pointer-events: none;
        }
        
        #start-screen, #win-screen {
            position: absolute;
            top: 100px;
            left: 0;
            right: 0;
            bottom: 100px;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 20px;
            text-align: center;
            background: radial-gradient(circle at center, rgba(20,0,0,0.7) 0%, rgba(0,0,0,0.9) 70%);
            border: 1px solid #500;
            box-shadow: 0 0 30px rgba(150,0,0,0.5);
        }
        
        .screen-title {
            font-size: 32px;
            margin-bottom: 20px;
            color: #f0f0f0;
            text-shadow: 0 0 10px rgba(255,0,0,0.7);
            letter-spacing: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .screen-content {
            max-width: 80%;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #ddd;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(255,0,0,0.5);
            background: rgba(10,0,0,0.3);
            padding: 15px;
            border: 1px solid #500;
            border-radius: 5px;
        }
        
        .screen-content p {
            margin: 10px 0;
        }
        
        .screen-button {
            padding: 15px 40px;
            background: linear-gradient(145deg, #b00, #800);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            border: 1px solid #d00;
        }
        
        .screen-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(150,0,0,0.6);
            background: linear-gradient(145deg, #d00, #a00);
        }
        
        #joystick-container {
            position: absolute;
            bottom: 120px;
            left: 30px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(30, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid rgba(200, 0, 0, 0.3);
            box-shadow: 0 0 20px rgba(100,0,0,0.5);
        }
        
        #joystick {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,100,100,0.5) 0%, rgba(200,0,0,0.3) 100%);
            position: relative;
            box-shadow: 0 0 10px rgba(150,0,0,0.3);
        }
        
        #instructions {
            margin-top: 10px;
            color: #888;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        #coordinates {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 14px;
            color: #f0f0f0;
            background: rgba(20,0,0,0.6);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 15;
            border: 1px solid rgba(200,0,0,0.2);
            box-shadow: 0 0 10px rgba(100,0,0,0.5);
            font-family: 'Courier New', monospace;
        }
        
        #exit-button {
            position: absolute;
            top: 12px;
            left: 10px;
            font-size: 14px;
            color: white;
            background: rgba(200, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 15;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 0 10px rgba(150,0,0,0.3);
            font-family: 'Courier New', monospace;
        }
        
        #exit-button:hover {
            background: rgba(230, 0, 0, 0.8);
            transform: scale(1.05);
        }
        
        .glitch-text {
            position: relative;
            display: inline-block;
            font-family: 'Courier New', monospace;
            animation: glitch 1s infinite;
        }
        
        @keyframes glitch {
            0% { text-shadow: 2px 0 red; }
            5% { text-shadow: -2px 0 blue; }
            10% { text-shadow: 2px 0 red, -2px 0 blue; }
            15% { text-shadow: none; }
            100% { text-shadow: none; }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; text-shadow: 0 0 15px rgba(255,0,0,0.8); }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .secret-door {
            position: absolute;
            width: 40px;
            height: 80px;
            background: rgba(150, 100, 50, 0.8);
            border: 3px solid #321;
            z-index: 5;
            box-shadow: 0 0 20px rgba(150,100,50,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #321;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            padding: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .secret-door:hover {
            background: rgba(200, 150, 100, 0.9);
            box-shadow: 0 0 30px rgba(200,150,100,0.8);
        }
        
        .hint {
            position: absolute;
            background: rgba(20,0,0,0.7);
            color: #f88;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 200px;
            text-align: center;
            border: 1px solid #a00;
            box-shadow: 0 0 10px rgba(150,0,0,0.5);
            z-index: 15;
            font-family: 'Courier New', monospace;
            animation: fadeInOut 3s infinite;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="game-title" class="glitch-text">E̲̅҉̲̅n̲̅҉̲̅d̲̅҉̲̅l̲̅҉̲̅e̲̅҉̲̅s̲̅҉̲̅s̲̅҉̲̅ ̲̅҉̲̅d̲̅҉̲̅r̲̅҉̲̅e̲̅҉̲̅a̲̅҉̲̅m</div>
    </div>
    
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="coordinates" style="display: none;">X: 1.5 Y: 1.5</div>
        <div id="exit-button" style="display: none;" class="pulse">Y̲̅҉̲̅o̲̅҉̲̅u̲̅҉̲̅ ̲̅҉̲̅w̲̅҉̲̅a̲̅҉̲̅n̲̅҉̲̅t̲̅҉̲̅ ̲̅҉̲̅t̲̅҉̲̅o̲̅҉̲̅ ̲̅҉̲̅g̲̅҉̲̅e̲̅҉̲̅t̲̅҉̲̅ ̲̅҉̲̅o̲̅҉̲̅u̲̅҉̲̅t̲̅҉̲̅?̲̅҉̲̅</div>
        
        <div id="start-screen">
            <div class="screen-title glitch-text">E̲̅҉̲̅n̲̅҉̲̅d̲̅҉̲̅l̲̅҉̲̅e̲̅҉̲̅s̲̅҉̲̅s̲̅҉̲̅ ̲̅҉̲̅d̲̅҉̲̅r̲̅҉̲̅e̲̅҉̲̅a̲̅҉̲̅m</div>
            <div class="screen-content">
                <p>F҉̅҉̲҉i҉̅҉̲҉x҉̅҉̲҉e҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉p҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉t҉̅҉̲҉e҉̅҉̲҉r҉̅҉̲҉n҉̅҉̲҉ ҉̅҉̲҉o҉̅҉̲҉f҉̅҉̲҉ ҉̅҉̲҉d҉̅҉̲҉e҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉h҉̅҉̲҉ ҉̅҉̲҉a҉̅҉̲҉n҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉e҉̅҉̲҉v҉̅҉̲҉i҉̅҉̲҉l҉̅҉̲҉</p>
                <p>？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅</p>
                <p class="pulse">don't you<br>wonder<br>whats<br>inside?</p>
            </div>
            <button class="screen-button pulse" id="start-button">S҉̅҉̲҉t҉̅҉̲҉a҉̅҉̲҉r҉̅҉̲҉t҉̅҉̲҉ ҉̅҉̲҉a҉̅҉̲҉ ҉̅҉̲҉n҉̅҉̲҉i҉̅҉̲҉g҉̅҉̲҉h҉̅҉̲҉t҉̅҉̲҉m҉̅҉̲҉a҉̅҉̲҉r҉̅҉̲҉e҉̅҉̲҉</button>
        </div>
        
        <div id="win-screen" style="display: none;">
            <div class="screen-title"></div>
            <div class="screen-content">
                <p class="pulse">Goodbye!<br>I am leaving</p>
                <p></p>
            </div>
            <button class="screen-button pulse" id="restart-button">F҉̅҉̲҉i҉̅҉̲҉x҉̅҉̲҉e҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉p҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉t҉̅҉̲҉e҉̅҉̲҉r҉̅҉̲҉n҉̅҉̲҉ ҉̅҉̲҉o҉̅҉̲҉f҉̅҉̲҉ ҉̅҉̲҉d҉̅҉̲҉e҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉h҉̅҉̲҉ ҉̅҉̲҉a҉̅҉̲҉n҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉e҉̅҉̲҉v҉̅҉̲҉i҉̅҉̲҉l҉̅҉̲҉</button>
        </div>
        
        <div id="joystick-container">
            <div id="joystick"></div>
        </div>
        
        <div class="secret-door" style="top: 30%; left: 10%;" id="secret-door">
            SECRET<br>EXIT
        </div>
        
        <div class="hint" style="top: 10%; right: 10%;">Find the hidden exit<br>to escape this nightmare</div>
    </div>
    
    <div id="controls">
        <div>F҉̅҉̲҉i҉̅҉̲҉x҉̅҉̲҉e҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉p҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉t҉̅҉̲҉e҉̅҉̲҉r҉̅҉̲҉n҉̅҉̲҉ ҉̅҉̲҉o҉̅҉̲҉f҉̅҉̲҉ ҉̅҉̲҉d҉̅҉̲҉e҉̅҉̲҉a҉̅҉̲҉t҉̅҉̲҉h҉̅҉̲҉ ҉̅҉̲҉a҉̅҉̲҉n҉̅҉̲҉d҉̅҉̲҉ ҉̅҉̲҉e҉̅҉̲҉v҉̅҉̲҉i҉̅҉̲҉l҉̅҉̲҉</div>
        <div id="instructions">？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅？̲̅҉̲̅</div>
    </div>

    <script>
        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.startScreen = document.getElementById('start-screen');
                this.winScreen = document.getElementById('win-screen');
                this.startButton = document.getElementById('start-button');
                this.restartButton = document.getElementById('restart-button');
                this.instructions = document.getElementById('instructions');
                this.coordinatesDisplay = document.getElementById('coordinates');
                this.exitButton = document.getElementById('exit-button');
                this.secretDoor = document.getElementById('secret-door');
                
                // 游戏状态
                this.gameStarted = false;
                this.gameWon = false;
                this.doorFound = false;
                
                // 迷宫参数
                this.mazeSize = 31;
                this.cellSize = 1;
                this.wallHeight = 1;
                
                // 玩家参数
                this.playerX = 1.5;
                this.playerY = 1.5;
                this.playerAngle = Math.PI / 4;
                this.playerPitch = 0; // 垂直视角
                this.playerSpeed = 0.05;
                this.rotationSpeed = 0.03;
                this.pitchSpeed = 0.02;
                this.maxPitch = Math.PI / 4; // 最大俯仰角
                
                // 3D渲染参数
                this.fov = Math.PI / 3;
                this.halfFov = this.fov / 2;
                this.stripeWidth = 1; // 初始值，将在resize中更新
                this.maxDepth = 16;
                
                // 控制参数
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.isRotating = false;
                this.isPitching = false;
                this.joystickActive = false;
                this.joystickX = 0;
                this.joystickY = 0;
                this.moveDirection = { x: 0, y: 0 };
                
                // 纹理
                this.wallTexture = this.createWallTexture();
                this.skyTexture = this.createSkyTexture();
                
                // 初始化
                this.init();
            }
            
            createWallTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // 创建砖墙纹理
                const brickWidth = 32;
                const brickHeight = 16;
                const mortar = 2;
                
                ctx.fillStyle = '#5a3825';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#8b5a2b';
                for (let y = 0; y < canvas.height; y += brickHeight + mortar) {
                    for (let x = 0; x < canvas.width; x += brickWidth + mortar) {
                        // 交错排列
                        const offset = (y / (brickHeight + mortar)) % 2 === 0 ? 0 : brickWidth / 2;
                        ctx.fillRect(x + offset, y, brickWidth, brickHeight);
                    }
                }
                
                // 添加污渍
                ctx.fillStyle = 'rgba(50, 20, 10, 0.3)';
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = 10 + Math.random() * 30;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return canvas;
            }
            
            createSkyTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // 创建深色天空纹理
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a0a0a');
                gradient.addColorStop(1, '#0a0000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 添加星星
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height / 2;
                    const size = Math.random() * 1.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 添加红色星云
                ctx.fillStyle = 'rgba(100, 0, 0, 0.1)';
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height / 3;
                    const size = 50 + Math.random() * 100;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return canvas;
            }
            
            init() {
                // 设置画布尺寸
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // 生成迷宫
                this.generateMaze();
                
                // 设置终点
                this.endX = this.mazeSize - 2;
                this.endY = this.mazeSize - 2;
                
                // 事件监听
                this.setupEventListeners();
                
                // 开始游戏循环
                this.gameLoop();
            }
            
            resizeCanvas() {
                const container = document.getElementById('game-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // 动态计算射线数量和条纹宽度
                const targetStripeWidth = 1.5; // 目标条纹宽度(像素)
                this.numRays = Math.floor(this.canvas.width / targetStripeWidth);
                this.stripeWidth = this.canvas.width / this.numRays;
                
                // 限制最大射线数量以保证性能
                const maxRays = 640;
                if (this.numRays > maxRays) {
                    this.numRays = maxRays;
                    this.stripeWidth = this.canvas.width / this.numRays;
                }
                
                // 调整摇杆位置
                const joystick = document.getElementById('joystick-container');
                joystick.style.bottom = '120px';
            }
            
            generateMaze() {
                // 创建初始网格，所有墙都存在
                this.maze = Array(this.mazeSize).fill().map(() => 
                    Array(this.mazeSize).fill(1)
                );
                
                // 使用深度优先搜索算法生成迷宫
                const stack = [];
                const startX = 1, startY = 1;
                
                // 设置起点为通路
                this.maze[startY][startX] = 0;
                stack.push([startX, startY]);
                
                // 四个方向
                const directions = [
                    [1, 0],  // 右
                    [0, 1],  // 下
                    [-1, 0], // 左
                    [0, -1]  // 上
                ];
                
                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                    
                    let found = false;
                    
                    for (const [dx, dy] of shuffledDirections) {
                        const nx = x + dx * 2;
                        const ny = y + dy * 2;
                        
                        if (nx > 0 && nx < this.mazeSize - 1 && 
                            ny > 0 && ny < this.mazeSize - 1 && 
                            this.maze[ny][nx] === 1) {
                            
                            // 打通墙壁
                            this.maze[y + dy][x + dx] = 0;
                            this.maze[ny][nx] = 0;
                            stack.push([nx, ny]);
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        stack.pop();
                    }
                }
            }
            
            setupEventListeners() {
                // 开始按钮
                this.startButton.addEventListener('click', () => {
                    this.startScreen.style.display = 'none';
                    this.coordinatesDisplay.style.display = 'block';
                    this.exitButton.style.display = 'block';
                    this.gameStarted = true;
                });
                
                // 退出按钮
                this.exitButton.addEventListener('click', () => {
                    this.startScreen.style.display = 'flex';
                    this.winScreen.style.display = 'none';
                    this.coordinatesDisplay.style.display = 'none';
                    this.exitButton.style.display = 'none';
                    this.gameStarted = false;
                    this.gameWon = false;
                    this.playerX = 1.5;
                    this.playerY = 1.5;
                    this.playerAngle = Math.PI / 4;
                    this.playerPitch = 0;
                    this.doorFound = false;
                });
                
                // 重新开始按钮
                this.restartButton.addEventListener('click', () => {
                    this.winScreen.style.display = 'none';
                    this.playerX = 1.5;
                    this.playerY = 1.5;
                    this.playerAngle = Math.PI / 4;
                    this.playerPitch = 0;
                    this.gameWon = false;
                    this.doorFound = false;
                    this.generateMaze();
                });
                
                // 触摸控制 - 旋转视角
                this.canvas.addEventListener('touchstart', (e) => {
                    if (!this.gameStarted || this.gameWon) return;
                    
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    
                    // 判断是水平旋转还是垂直视角调整
                    if (touch.clientX > this.canvas.width / 2) {
                        this.isRotating = true;
                    } else {
                        this.isPitching = true;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    if (!this.gameStarted || this.gameWon) return;
                    
                    const touch = e.touches[0];
                    
                    if (this.isRotating) {
                        const deltaX = touch.clientX - this.touchStartX;
                        // 旋转视角
                        this.playerAngle += deltaX * 0.01;
                        this.touchStartX = touch.clientX;
                    }
                    
                    if (this.isPitching) {
                        const deltaY = touch.clientY - this.touchStartY;
                        // 调整垂直视角
                        this.playerPitch -= deltaY * 0.01;
                        // 限制垂直视角范围
                        this.playerPitch = Math.max(-this.maxPitch, Math.min(this.maxPitch, this.playerPitch));
                        this.touchStartY = touch.clientY;
                    }
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.isRotating = false;
                    this.isPitching = false;
                });
                
                // 摇杆控制
                const joystick = document.getElementById('joystick');
                const joystickContainer = document.getElementById('joystick-container');
                const joystickRadius = 50;
                const containerRect = joystickContainer.getBoundingClientRect();
                const containerCenter = {
                    x: containerRect.left + containerRect.width / 2,
                    y: containerRect.top + containerRect.height / 2
                };
                
                joystick.addEventListener('touchstart', (e) => {
                    if (!this.gameStarted || this.gameWon) return;
                    
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0]);
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!this.gameStarted || this.gameWon || !this.joystickActive) return;
                    
                    this.updateJoystick(e.touches[0]);
                });
                
                document.addEventListener('touchend', () => {
                    this.joystickActive = false;
                    this.moveDirection = { x: 0, y: 0 };
                    joystick.style.transform = 'translate(0, 0)';
                });
                
                // 秘密出口点击事件
                this.secretDoor.addEventListener('click', () => {
                    if (this.gameStarted && !this.gameWon) {
                        this.doorFound = true;
                        this.gameWon = true;
                        this.winScreen.style.display = 'flex';
                    }
                });
            }
            
            updateJoystick(touch) {
                const joystick = document.getElementById('joystick');
                const joystickContainer = document.getElementById('joystick-container');
                const containerRect = joystickContainer.getBoundingClientRect();
                const containerCenter = {
                    x: containerRect.left + containerRect.width / 2,
                    y: containerRect.top + containerRect.height / 2
                };
                const joystickRadius = 25;
                
                // 计算触摸点相对于摇杆中心的位置
                let deltaX = touch.clientX - containerCenter.x;
                let deltaY = touch.clientY - containerCenter.y;
                
                // 限制摇杆移动范围
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > joystickRadius) {
                    deltaX = (deltaX / distance) * joystickRadius;
                    deltaY = (deltaY / distance) * joystickRadius;
                }
                
                // 更新摇杆位置
                joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                // 计算移动方向 (归一化) - 反转Y轴方向
                this.moveDirection = {
                    x: deltaX / joystickRadius,
                    y: -deltaY / joystickRadius  // 反转Y轴
                };
            }
            
            update(deltaTime) {
                if (!this.gameStarted || this.gameWon) return;
                
                // 更新坐标显示
                this.coordinatesDisplay.textContent = `X: ${this.playerX.toFixed(1)} Y: ${this.playerY.toFixed(1)}`;
                
                // 移动玩家
                if (this.moveDirection.x !== 0 || this.moveDirection.y !== 0) {
                    const moveX = Math.cos(this.playerAngle) * this.moveDirection.y * this.playerSpeed;
                    const moveY = Math.sin(this.playerAngle) * this.moveDirection.y * this.playerSpeed;
                    
                    // 同时支持左右移动
                    const strafeX = Math.cos(this.playerAngle + Math.PI/2) * this.moveDirection.x * this.playerSpeed * 0.4;
                    const strafeY = Math.sin(this.playerAngle + Math.PI/2) * this.moveDirection.x * this.playerSpeed * 0.4;
                    
                    const newX = this.playerX + moveX + strafeX;
                    const newY = this.playerY + moveY + strafeY;
                    
                    // 碰撞检测
                    if (this.maze[Math.floor(newY)][Math.floor(newX)] === 0) {
                        this.playerX = newX;
                        this.playerY = newY;
                    }
                }
                
                // 检查是否到达终点
                if (Math.floor(this.playerX) === this.endX && Math.floor(this.playerY) === this.endY) {
                    this.instructions.textContent = "Y̲̅҉̲̅o̲̅҉̲̅u̲̅҉̲̅ ̲̅҉̲̅f̲̅҉̲̅o̲̅҉̲̅u̲̅҉̲̅n̲̅҉̲̅d̲̅҉̲̅ ̲̅҉̲̅t̲̅҉̲̅h̲̅҉̲̅e̲̅҉̲̅ ̲̅҉̲̅e̲̅҉̲̅x̲̅҉̲̅i̲̅҉̲̅t̲̅҉̲̅?̲̅҉̲̅";
                }
            }
            
            draw() {
                if (!this.gameStarted) return;
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // 清空画布
                this.ctx.clearRect(0, 0, width, height);
                
                // 绘制3D视图
                this.draw3DView();
            }
            
            draw3DView() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // 绘制天空
                const skyOffset = (this.playerAngle / (Math.PI * 2)) * this.skyTexture.width;
                // 绘制天空（使用贴图）
                this.ctx.drawImage(
                    this.skyTexture,
                    skyOffset, 0, 
                    Math.min(width, this.skyTexture.width - skyOffset), this.skyTexture.height,
                    0, 0, 
                    Math.min(width, this.skyTexture.width - skyOffset), height / 2
                );
                
                // 如果需要，绘制剩余的天空部分
                if (width > this.skyTexture.width - skyOffset) {
                    this.ctx.drawImage(
                        this.skyTexture,
                        0, 0,
                        width - (this.skyTexture.width - skyOffset), this.skyTexture.height,
                        this.skyTexture.width - skyOffset, 0,
                        width - (this.skyTexture.width - skyOffset), height / 2
                    );
                }
                
                // 绘制地面
                const groundGradient = this.ctx.createLinearGradient(0, height/2, 0, height);
                groundGradient.addColorStop(0, '#2c1e1e');
                groundGradient.addColorStop(1, '#1a0a0a');
                this.ctx.fillStyle = groundGradient;
                this.ctx.fillRect(0, height / 2, width, height / 2);
                
                // 添加地面网格线
                this.ctx.strokeStyle = 'rgba(100, 0, 0, 0.2)';
                this.ctx.lineWidth = 1;
                for (let i = 1; i < 10; i++) {
                    const yPos = height/2 + i * 30;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, yPos);
                    this.ctx.lineTo(width, yPos);
                    this.ctx.stroke();
                }
                
                // 射线投射
                for (let i = 0; i < this.numRays; i++) {
                    const rayAngle = this.playerAngle - this.halfFov + (i / this.numRays) * this.fov;
                    
                    // 初始化射线
                    let rayX = this.playerX;
                    let rayY = this.playerY;
                    
                    // 射线方向单位向量
                    const rayDirX = Math.cos(rayAngle);
                    const rayDirY = Math.sin(rayAngle);
                    
                    // 防止除以0
                    const deltaDistX = rayDirX === 0 ? 1e30 : Math.abs(1 / rayDirX);
                    const deltaDistY = rayDirY === 0 ? 1e30 : Math.abs(1 / rayDirY);
                    
                    // 初始化DDA算法
                    let mapX = Math.floor(rayX);
                    let mapY = Math.floor(rayY);
                    
                    let sideDistX, sideDistY;
                    let stepX, stepY;
                    let hit = false;
                    let side; // 0表示x面，1表示y面
                    
                    // 计算步长和初始侧边距离
                    if (rayDirX < 0) {
                        stepX = -1;
                        sideDistX = (rayX - mapX) * deltaDistX;
                    } else {
                        stepX = 1;
                        sideDistX = (mapX + 1.0 - rayX) * deltaDistX;
                    }
                    
                    if (rayDirY < 0) {
                        stepY = -1;
                        sideDistY = (rayY - mapY) * deltaDistY;
                    } else {
                        stepY = 1;
                        sideDistY = (mapY + 1.0 - rayY) * deltaDistY;
                    }
                    
                    // DDA算法
                    let distance = 0;
                    while (!hit && distance < this.maxDepth) {
                        // 跳转到下一个地图方格
                        if (sideDistX < sideDistY) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                            side = 0;
                        } else {
                            sideDistY += deltaDistY;
                            mapY += stepY;
                            side = 1;
                        }
                        
                        // 检查是否击中墙壁
                        if (mapX < 0 || mapX >= this.mazeSize || mapY < 0 || mapY >= this.mazeSize) {
                            hit = true;
                        } else if (this.maze[mapY][mapX] === 1) {
                            hit = true;
                        }
                        
                        distance += 0.1;
                    }
                    
                    // 计算击中点的距离
                    let perpWallDist;
                    if (side === 0) {
                        perpWallDist = (mapX - rayX + (1 - stepX) / 2) / rayDirX;
                    } else {
                        perpWallDist = (mapY - rayY + (1 - stepY) / 2) / rayDirY;
                    }
                    
                    // 计算墙壁高度
                    let lineHeight = Math.floor(height / perpWallDist);
                    
                    // 应用垂直视角偏移
                    const pitchOffset = Math.tan(this.playerPitch) * height;
                    lineHeight = Math.floor(lineHeight * (1 + 0.5 * Math.abs(this.playerPitch)));
                    
                    // 计算绘制范围
                    let drawStart = -lineHeight / 2 + height / 2 + pitchOffset;
                    if (drawStart < 0) drawStart = 0;
                    let drawEnd = lineHeight / 2 + height / 2 + pitchOffset;
                    if (drawEnd >= height) drawEnd = height - 1;
                    
                    // 使用纹理绘制墙壁
                    if (hit) {
                        // 计算墙壁纹理坐标
                        let wallX;
                        if (side === 0) {
                            wallX = this.playerY + perpWallDist * rayDirY;
                        } else {
                            wallX = this.playerX + perpWallDist * rayDirX;
                        }
                        wallX -= Math.floor(wallX);
                        
                        // 纹理x坐标
                        let texX = Math.floor(wallX * this.wallTexture.width);
                        // 如果光线从反方向击中，反转纹理以避免镜像
                        if ((side === 0 && rayDirX > 0) || (side === 1 && rayDirY < 0)) {
                            texX = this.wallTexture.width - texX - 1;
                        }
                        
                        // 创建离屏canvas用于纹理绘制
                        const textureCanvas = document.createElement('canvas');
                        textureCanvas.width = 1;
                        textureCanvas.height = this.wallTexture.height;
                        const textureCtx = textureCanvas.getContext('2d');
                        textureCtx.drawImage(this.wallTexture, texX, 0, 1, this.wallTexture.height, 0, 0, 1, this.wallTexture.height);
                        
                        // 添加阴影效果
                        const shadowValue = Math.min(1, perpWallDist / 8);
                        textureCtx.fillStyle = `rgba(0, 0, 0, ${shadowValue})`;
                        textureCtx.fillRect(0, 0, 1, this.wallTexture.height);
                        
                        // 绘制墙壁条带
                        this.ctx.drawImage(
                            textureCanvas,
                            0, 0, 1, this.wallTexture.height,
                            i * this.stripeWidth, drawStart,
                            this.stripeWidth, drawEnd - drawStart
                        );
                    }
                    
                    // 绘制地板和天花板阴影
                    const floorColor = `rgba(50, 20, 20, ${0.3 + 0.7 * (drawEnd / height)})`;
                    this.ctx.fillStyle = floorColor;
                    this.ctx.fillRect(i * this.stripeWidth, drawEnd, this.stripeWidth, height - drawEnd);
                    
                    const ceilingColor = `rgba(50, 10, 10, ${0.3 + 0.7 * (1 - drawStart / height)})`;
                    this.ctx.fillStyle = ceilingColor;
                    this.ctx.fillRect(i * this.stripeWidth, 0, this.stripeWidth, drawStart);
                }
                
                // 添加雾气效果
                const fogGradient = this.ctx.createLinearGradient(0, height/2, 0, height);
                fogGradient.addColorStop(0, 'transparent');
                fogGradient.addColorStop(1, 'rgba(20, 0, 0, 0.7)');
                this.ctx.fillStyle = fogGradient;
                this.ctx.fillRect(0, height/2, width, height/2);
            }
            
            gameLoop(timestamp = 0) {
                // 计算时间增量
                if (!this.lastFrameTime) this.lastFrameTime = timestamp;
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;
                
                // 更新游戏状态
                this.update(deltaTime);
                
                // 绘制游戏
                this.draw();
                
                // 继续循环
                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }
        
        // 启动游戏
        const game = new MazeGame();
    </script>
</body>
</html>